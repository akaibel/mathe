<!--
  This file is part of Zeichenfl√§che mit Geodreieck.

  Copyright (C) 2025 Andreas Kaibel

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->


<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zeichenfl√§che mit Geodreieck</title>
    <style>
        body {
            margin: 0;
            background: #fff;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            font-family: sans-serif;
        }

        canvas {
            touch-action: none;
        }

        #toolbar-left,
        #toolbar-right {
            position: fixed;
            bottom: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        #toolbar-left {
            left: 20px;
        }

        #toolbar-right {
            right: 20px;
        }

        button {
            padding: 10px 14px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background: #f2f2f2;
            font-size: 14px;
        }

        .color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
            padding: 0;
        }

        .color-btn.active {
            border: 3px solid black;
        }

        #geo {
            touch-action: none;
            position: fixed;
            left: 50%;
            top: 50%;
            width: 600px;
            opacity: 0.85;
            touch-action: none;
            z-index: 5;
        }

        #geo-mode {
            position: fixed;
            bottom: 80px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 10;
        }

        .popup {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        .popup.hidden {
            display: none;
        }

        .popup-box {
            background: white;
            padding: 20px 26px;
            border-radius: 12px;
            min-width: 220px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        .popup-box h3 {
            margin-top: 0;
            margin-bottom: 14px;
        }

        .popup-box button {
            display: block;
            width: 100%;
            margin: 8px 0;
            font-size: 16px;
            padding: 10px;
        }
    </style>
</head>

<body>

    <canvas id="canvas"></canvas>
    <img id="geo" src="geodreieck.png" draggable="false">

    <input type="file" id="bg-file" accept="image/*" style="display:none">

    <div id="toolbar-left">
        <button id="mode-free">Freihand</button>
        <button id="mode-line">Linie</button>
        <button id="mode-poly">Vieleck</button>
        <button id="mode-circle">Kreis</button>
        <button id="mode-bg">Hintergrund</button>
        <input type="range" id="bg-opacity" min="0" max="100" value="100" style="width:80px; margin-left:10px;">
        <button id="undo">Zur√ºck</button>
        <button id="clear-all">L√∂schen</button>
    </div>

    <div id="geo-mode">
        <strong>Geodreieck</strong><br>
        <label><input type="radio" name="geoScale" value="flexible"> flexibel</label><br>
        <label><input type="radio" name="geoScale" value="fix" checked> feste Gr√∂√üe</label>
    </div>

    <div id="toolbar-right">
        <button class="color-btn active" data-color="#000000" style="background:black;"></button>
        <button class="color-btn" data-color="#ff0000" style="background:red;"></button>
        <button class="color-btn" data-color="#0000ff" style="background:blue;"></button>
        <button class="color-btn" data-color="#ff8800" style="background:orange;"></button>
    </div>

    <!-- popup-fenster fuer die hintergrund-auswahl -->
    <div id="bg-popup" class="popup hidden">
        <div class="popup-box">
            <h3>Hintergrund w√§hlen</h3>
            <button id="bg-grid-btn">Karos</button>
            <button id="bg-white-btn">Wei&szlig;</button>
            <button id="bg-image-btn">Bild laden</button>
            <button id="bg-cancel-btn">Abbrechen</button>
        </div>
    </div>

    <script>
        /* ==================== CANVAS & STATE ==================== */
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let bgType = null; // 'image' oder 'grid' oder null (=kein Hintergrund)

        const geoStartSizeWidth = 500; // Startbreite des Geodreiecks in Pixel
        const karoGeodreieckRatio = 0.0312; // Breite eines Karos im Verhaeltnis zur Breite des Geodreiecks

        const geoPadding = 30; // Pixel

        const snap_abstand = 30;
        const snap_to = 0;
        const line_width = 2;

        let drawing = false;
        let geoDrawingMode = false;

        let penBlockedByGeo = false;

        let freeDrawingAllowed = true;


        let mode = 'free'; // line | free | poly | circle | bg
        let currentColor = '#000000';
        let startPoint = null;
        let circleCenter = null;

        let polygonPoints = [];
        let freePoints = [];

        let history = [];

        let groupCounter = 1; // fuer Linien bzw. Polygon-Zeichnungen
        let currentGroup = null;


        let geoScaleMode = 'fixed'; // 'flexible' oder 'fix'

        /* 
        * fuer Linien bzw. Polygon-Zeichnungen
        * alle Linien und PUnkte, die zu einer Linie bzw. Polygon gehoeren
        * haben die gleiche Gruppe
        */
        function newGroup() {
            currentGroup = groupCounter++;
            return currentGroup;
        }


        /* ==================== GEO ==================== */
        const geo = document.getElementById('geo');

        let baseTransform = { x: 0, y: 0, scale: 1, angle: 0 };
        let geoStartTransform = null;
        let touches = [];
        let startGesture = null;

        // startgroesse des geodreiecks festlegen
        window.addEventListener('load', () => {

            const originalWidth = geo.naturalWidth;
            const originalHeight = geo.naturalHeight;

            const ratio = originalHeight / originalWidth;

            const newWidth = geoStartSizeWidth;
            const newHeight = geoStartSizeWidth * ratio;

            // CSS aendern
            geo.style.width = newWidth + "px";
            geo.style.height = newHeight + "px";

        });


        function cloneGeo() { return { ...baseTransform }; }
        function updateGeo() {
            geo.style.transform = `translate(${baseTransform.x}px,${baseTransform.y}px) rotate(${baseTransform.angle}rad) scale(${baseTransform.scale})`;
        }


        function getDelta(prev, curr) {
            return {
                dx: curr.clientX - prev.clientX,
                dy: curr.clientY - prev.clientY
            };
        }

        /* ==================== BACKGROUND ==================== */
        let bgImage = null;
        let bgTransform = { x: 0, y: 0, scale: 1, angle: 0 };
        let bgStartTransform = null;
        let bgTouches = [];
        let bgStartGesture = null;
        let bgOpacity = 1;

        const btnBg = document.getElementById('mode-bg');
        const bgFileInput = document.getElementById('bg-file');
        const bgOpacityInput = document.getElementById('bg-opacity');
        let bgClickTimeout = null;

        const bgPopup = document.getElementById("bg-popup");
        const btnGrid = document.getElementById("bg-grid-btn");
        const btnWhite = document.getElementById("bg-white-btn");
        const btnImage = document.getElementById("bg-image-btn");
        const btnCancel = document.getElementById("bg-cancel-btn");

        btnBg.addEventListener("click", () => {
            bgPopup.classList.remove("hidden");
        });

        btnCancel.onclick = () => {
            bgPopup.classList.add("hidden");
        };

        btnGrid.onclick = () => {
            bgType = "grid";
            mode = "free";   // zurueck zum Zeichnen
            setActive();
            redrawCanvas();
            bgPopup.classList.add("hidden");
        };

        btnWhite.onclick = () => {
            bgType = null;     // kein Hintergrund
            mode = "free";    // zurueck zum Zeichnen
            setActive();
            redrawCanvas();
            bgPopup.classList.add("hidden");
        };


        btnImage.onclick = () => {
            bgType = "image";
            bgFileInput.click();
            bgPopup.classList.add("hidden");
        };

        // Doppelklick ‚Üí neues Bild hochladen
        btnBg.addEventListener('dblclick', () => {
            bgFileInput.click();
        });

        bgFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const img = new Image();
            img.onload = () => {
                bgImage = img;
                bgTransform = { x: 0, y: 0, scale: 1, angle: 0 };
                // automatisch Hintergrund-Modus aktivieren
                mode = 'bg';
                setActive();
                redrawCanvas();
            };
            img.src = URL.createObjectURL(file);
            bgFileInput.value = '';
        });

        bgOpacityInput.addEventListener('input', () => {
            bgOpacity = bgOpacityInput.value / 100;
            redrawCanvas();
        });

        /* ==================== TOOLBAR ==================== */
        const btnLine = document.getElementById('mode-line');
        const btnFree = document.getElementById('mode-free');
        const btnPoly = document.getElementById('mode-poly');
        const btnCircle = document.getElementById('mode-circle');
        const btnUndo = document.getElementById('undo');
        const btnClear = document.getElementById('clear-all');

        function setActive() {
            document.querySelectorAll('#toolbar-left button').forEach(b => b.style.background = '');
            document.getElementById('mode-' + mode).style.background = 'lightgreen';
        }
        setActive();

        btnLine.onclick = () => { resetTempStates(); mode = 'line'; setActive(); };
        btnFree.onclick = () => { resetTempStates(); mode = 'free'; setActive(); };
        btnPoly.onclick = () => { resetTempStates(); mode = 'poly'; polygonPoints = []; setActive(); };
        btnCircle.onclick = () => { resetTempStates(); mode = 'circle'; circleCenter = null; setActive(); };

        btnUndo.onclick = () => {

            if (history.length === 0) return;

            const lastGroup = history[history.length - 1].group;

            // Elemente ohne Gruppe (z.B. geo-Transform) einzeln behandeln
            if (lastGroup === undefined) {
                const item = history.pop();
                if (item.type === 'geo') {
                    baseTransform = { ...item.from };
                    updateGeo();
                }
                redrawCanvas();
                return;
            }

            // komplette Konstruktion l√∂schen
            history = history.filter(item => item.group !== lastGroup);

            redrawCanvas();
        };

        btnClear.onclick = () => {
            // nur Zeichnung l√∂schen
            history = [];
            polygonPoints = [];
            startPoint = null;
            circleCenter = null;
            freePoints = [];
            drawing = false;

            // Canvas neu zeichnen ‚Üí Hintergrund bleibt
            redrawCanvas();
        };



        /* ==================== COLORS ==================== */
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.onclick = () => {
                currentColor = btn.dataset.color;
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            }
        });

        /* ==================== GEO SCALE ==================== */
        document.querySelectorAll('input[name="geoScale"]').forEach(r => {
            r.addEventListener('change', () => geoScaleMode = r.value);
        });

        /* ==================== REDRAW ==================== */
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // background
            if (bgType === "image" && bgImage) {

                ctx.save();
                ctx.translate(bgTransform.x + canvas.width / 2, bgTransform.y + canvas.height / 2);
                ctx.rotate(bgTransform.angle);
                ctx.scale(bgTransform.scale, bgTransform.scale);
                ctx.globalAlpha = bgOpacity;
                ctx.drawImage(bgImage, -bgImage.width / 2, -bgImage.height / 2);
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            if (bgType === "grid") {

                ctx.save();
                ctx.globalAlpha = bgOpacity;
                ctx.strokeStyle = "#b7d7ff"; // hellblau
                ctx.lineWidth = 1;

                // aktuelle Breite des Geodreiecks inkl. Skalierung
                const aktuelleGeoBreite = geo.width * baseTransform.scale;

                // neues Karo-Ma√ü berechnen
                const karopapierDistance = aktuelleGeoBreite * karoGeodreieckRatio;


                for (let x = 0; x < canvas.width; x += karopapierDistance) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }

                for (let y = 0; y < canvas.height; y += karopapierDistance) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                ctx.restore();
            }
            for (const item of history) {
                if (item.type === 'geo') continue;
                ctx.strokeStyle = item.color;
                ctx.lineWidth = line_width;
                if (item.type === 'point') {
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    continue;
                }
                ctx.beginPath();
                if (item.type === 'line') { ctx.moveTo(item.a.x, item.a.y); ctx.lineTo(item.b.x, item.b.y); }
                if (item.type === 'free' || item.type === 'poly') { ctx.moveTo(item.points[0].x, item.points[0].y); item.points.forEach(p => ctx.lineTo(p.x, p.y)); if (item.type === 'poly') ctx.closePath(); }
                if (item.type === 'circle') {
                    ctx.arc(item.center.x, item.center.y, item.radius, 0, Math.PI * 2);
                }

                ctx.stroke();
            }

            // ===== Polygon-Vorschau (w√§hrend Konstruktion) =====
            if (mode === 'poly' && polygonPoints.length > 0) {

                ctx.strokeStyle = currentColor;
                ctx.lineWidth = line_width;

                ctx.beginPath();
                ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);

                for (let i = 1; i < polygonPoints.length; i++) {
                    ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
                }

                ctx.stroke();
            }

        }

        /* ==================== SNAP ==================== */
        function transformGeoPoint(px, py) {

            // echte Bildschirmposition des gedrehten & skalierten Bildes
            const rect = geo.getBoundingClientRect();

            const w = geo.width;
            const h = geo.height;

            // Mittelpunkt des Bildes im lokalen System
            let x = px - w / 2;
            let y = py - h / 2;

            // Skalierung
            x *= baseTransform.scale;
            y *= baseTransform.scale;

            // Rotation
            const cosA = Math.cos(baseTransform.angle);
            const sinA = Math.sin(baseTransform.angle);

            const xr = x * cosA - y * sinA;
            const yr = x * sinA + y * cosA;

            // !!! echte Bildschirmposition !!!
            const screenX = rect.left + rect.width / 2 + xr;
            const screenY = rect.top + rect.height / 2 + yr;

            return { x: screenX, y: screenY };
        }

        function distancePointToSegment(P, A, B) {

            const ABx = B.x - A.x;
            const ABy = B.y - A.y;

            const APx = P.x - A.x;
            const APy = P.y - A.y;

            const ab2 = ABx * ABx + ABy * ABy;
            const ap_ab = APx * ABx + APy * ABy;

            let t = ap_ab / ab2;

            // Projektion auf Segment begrenzen
            t = Math.max(0, Math.min(1, t));

            const closestX = A.x + ABx * t;
            const closestY = A.y + ABy * t;

            const dx = P.x - closestX;
            const dy = P.y - closestY;

            return Math.hypot(dx, dy);
        }


        function pointInTriangle(P, A, B, C) {

            // Vektoren
            const v0x = C.x - A.x;
            const v0y = C.y - A.y;

            const v1x = B.x - A.x;
            const v1y = B.y - A.y;

            const v2x = P.x - A.x;
            const v2y = P.y - A.y;

            // Skalarprodukte
            const dot00 = v0x * v0x + v0y * v0y;
            const dot01 = v0x * v1x + v0y * v1y;
            const dot02 = v0x * v2x + v0y * v2y;
            const dot11 = v1x * v1x + v1y * v1y;
            const dot12 = v1x * v2x + v1y * v2y;

            // baryzentrische Koordinaten
            const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);

            const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

            // Punkt liegt im Dreieck?
            return (u >= 0) && (v >= 0) && (u + v <= 1);
        }

        function isPointInsideGeo(clientX, clientY, padding) {

            // echte Bildschirmposition (wichtig f√ºrs Scroll/Zoom Verhalten vom Browser)
            const rect = geo.getBoundingClientRect();

            const w = geo.width;
            const h = geo.height;

            // Dreieckspunkte in Bildschirmkoordinaten
            const A = transformGeoPoint(0, h);      // links unten
            const B = transformGeoPoint(w, h);      // rechts unten
            const C = transformGeoPoint(w / 2, 0);    // Spitze

            const P = { x: clientX, y: clientY };

            // Schritt 1: √ºberhaupt im Dreieck?
            if (!pointInTriangle(P, A, B, C)) {
                return false;
            }

            // Schritt 2: Abstand zu allen drei Kanten pr√ºfen
            const d1 = distancePointToSegment(P, A, B);
            const d2 = distancePointToSegment(P, B, C);
            const d3 = distancePointToSegment(P, C, A);

            const minDist = Math.min(d1, d2, d3);

            // Padding-Bedingung
            if (minDist >= padding) {
                return true;
            } else {
                return false;
            }
        }



        function distPointToLine(P, A, B) {
            return Math.abs((B.x - A.x) * (A.y - P.y) - (A.x - P.x) * (B.y - A.y)) / Math.hypot(B.x - A.x, B.y - A.y);
        }

        function isNearGeoBase(clientX, clientY) {

            const w = geo.width, h = geo.height;

            const A = transformGeoPoint(0, h);
            const B = transformGeoPoint(w, h);

            const ABx = B.x - A.x;
            const ABy = B.y - A.y;
            const lenAB = Math.hypot(ABx, ABy);

            const APx = clientX - A.x;
            const APy = clientY - A.y;

            // Projektion auf Segment
            const proj = (APx * ABx + APy * ABy) / lenAB;

            if (proj < 0 || proj > lenAB) return false;

            // echter Abstand zur Linie
            const distance = Math.abs(ABx * APy - ABy * APx) / lenAB;

            return distance < snap_abstand;
        }


        function snapToGeo(Px, Py) {

            const w = geo.width, h = geo.height;

            // Grundlinie des Geodreiecks
            const A = transformGeoPoint(0, h);
            const B = transformGeoPoint(w, h);

            // Richtungsvektor AB
            const ABx = B.x - A.x;
            const ABy = B.y - A.y;
            const lenAB = Math.hypot(ABx, ABy);

            // normierter Richtungsvektor
            const ux = ABx / lenAB;
            const uy = ABy / lenAB;

            // Vektor AP
            const APx = Px - A.x;
            const APy = Py - A.y;

            // Projektion auf AB
            const proj = APx * ux + APy * uy;

            // nur echtes Segment
            if (proj <= 0 || proj >= lenAB) {
                return { x: Px, y: Py, snapped: false };
            }

            // Kreuzprodukt -> sagt uns auf welcher Seite der Linie der Punkt liegt
            const cross = ABx * APy - ABy * APx;

            // Abstand zur Linie
            const distance = Math.abs(cross) / lenAB;

            if (distance > snap_abstand) {
                return { x: Px, y: Py, snapped: false };
            }

            // Fu√üpunkt berechnen
            const Fx = A.x + proj * ux;
            const Fy = A.y + proj * uy;

            return {
                x: Fx,
                y: Fy,
                snapped: true
            };
        }

        /* ==================== DRAWING ==================== */

        function resetTempStates() {
            startPoint = null;
            polygonPoints = [];
            freePoints = [];
            drawing = false;
            circleCenter = null;
        }


        canvas.addEventListener('pointerdown', e => {
            if (mode === 'bg') {
                e.preventDefault();
            }

            canvas.setPointerCapture(e.pointerId);

            if (mode === 'free') {
                freeDrawingAllowed = !isPointInsideGeo(e.clientX, e.clientY, 0);
            }

            const p = snapToGeo(e.clientX, e.clientY);

            if (mode === 'bg') {
                bgTouches.push(e);
                if (!bgStartTransform) bgStartTransform = { ...bgTransform };
                return;
            }

            if (mode === 'circle') {
                const p = snapToGeo(e.clientX, e.clientY);

                // 1. Klick ‚Üí Mittelpunkt
                if (!circleCenter) {
                    circleCenter = p;
                    newGroup();
                    history.push({
                        type: 'point',
                        group: currentGroup,
                        color: currentColor,
                        x: p.x,
                        y: p.y
                    });

                    redrawCanvas();
                }
                // 2. Klick ‚Üí Kreis
                else {
                    const dx = p.x - circleCenter.x;
                    const dy = p.y - circleCenter.y;
                    const radius = Math.hypot(dx, dy);

                    history.push({
                        type: 'circle',
                        group: currentGroup,
                        color: currentColor,
                        center: circleCenter,
                        radius
                    });
                    currentGroup = null;
                    circleCenter = null;
                    redrawCanvas();
                }
                return;
            }

            if (mode === 'line') {

                // ERSTER KLICK ‚Üí Startpunkt
                if (!startPoint) {
                    startPoint = p;
                    const g = newGroup();

                    history.push({
                        type: 'point',
                        group: g,
                        color: currentColor,
                        x: p.x,
                        y: p.y
                    });

                    redrawCanvas();
                    return;
                }

                // ZWEITER KLICK ‚Üí Linie
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = line_width;
                ctx.beginPath();
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.lineTo(p.x, p.y);
                ctx.stroke();

                history.push({
                    type: 'line',
                    group: currentGroup,
                    color: currentColor,
                    a: startPoint,
                    b: p
                });

                history.push({
                    type: 'point',
                    group: currentGroup,
                    color: currentColor,
                    x: p.x,
                    y: p.y
                });


                startPoint = null;
                redrawCanvas();
            }

            if (mode === 'free') {
                drawing = true;
                freePoints = [];

                if (freeDrawingAllowed) {
                    freePoints = [p];
                    ctx.strokeStyle = currentColor;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                }
            }

            if (mode === 'poly') {
                if (polygonPoints.length > 2) {
                    const first = polygonPoints[0];
                    if (Math.hypot(p.x - first.x, p.y - first.y) < 20) {
                        // Polygon schliessen
                        ctx.strokeStyle = currentColor;
                        ctx.lineWidth = line_width;
                        ctx.beginPath();
                        ctx.moveTo(first.x, first.y);
                        polygonPoints.forEach(pt => ctx.lineTo(pt.x, pt.y));
                        ctx.closePath();
                        ctx.stroke();
                        history.push({
                            type: 'poly',
                            group: currentGroup,
                            color: currentColor,
                            points: [...polygonPoints]
                        });
                        currentGroup = null;
                        polygonPoints = [];
                        redrawCanvas();
                        return;
                    }
                }
                if (polygonPoints.length === 0) {
                    newGroup();
                }

                polygonPoints.push(p);

                history.push({
                    type: 'point',
                    group: currentGroup,
                    color: currentColor,
                    x: p.x,
                    y: p.y
                });

                redrawCanvas();
            }

        });

        canvas.addEventListener('pointermove', e => {
            if (mode === 'bg' && bgTouches.length > 0) {
                e.preventDefault();

                // üîπ alten Touch ZUERST merken
                const prev = bgTouches.find(t => t.pointerId === e.pointerId);

                // üîπ dann Touch aktualisieren
                bgTouches = bgTouches.map(t => t.pointerId === e.pointerId ? e : t);

                // üîπ Verschieben (1 Finger)
                if (bgTouches.length === 1 && prev) {
                    const dx = e.clientX - prev.clientX;
                    const dy = e.clientY - prev.clientY;
                    bgTransform.x += dx;
                    bgTransform.y += dy;
                    redrawCanvas();
                }

                // üîπ Pinch / Rotate (2 Finger)
                if (bgTouches.length === 2) {
                    const [a, b] = bgTouches;
                    const dx = b.clientX - a.clientX;
                    const dy = b.clientY - a.clientY;
                    const dist = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);

                    if (!bgStartGesture) {
                        bgStartGesture = {
                            dist,
                            angle,
                            scale: bgTransform.scale,
                            rotation: bgTransform.angle
                        };
                    }

                    bgTransform.scale =
                        bgStartGesture.scale * (dist / bgStartGesture.dist);
                    bgTransform.angle =
                        bgStartGesture.rotation + (angle - bgStartGesture.angle);

                    redrawCanvas();
                }
                return;
            }

            // normales Zeichnen
            if (mode === 'free' && drawing) {

                const insideGeo = isPointInsideGeo(e.clientX, e.clientY, 0);
                const nearBase = isNearGeoBase(e.clientX, e.clientY);

                // ===============================
                // FALL 1: Stift trifft Geodreieck
                // ===============================
                if (insideGeo && !nearBase) {
                    if (freeDrawingAllowed) {
                        history.push({ type: 'free', color: currentColor, points: [...freePoints] });
                    }
                    freeDrawingAllowed = false;
                    return;
                }

                // ===============================
                // FALL 2: Stift kommt unter dem Geodreieck wieder raus
                // ===============================
                const p = snapToGeo(e.clientX, e.clientY);

                if (!freeDrawingAllowed) {
                    freeDrawingAllowed = true;
                    freePoints = [];

                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    freePoints.push(p);
                    return;
                }

                // ===============================
                // Normal zeichnen
                // ===============================
                ctx.lineTo(p.x, p.y);
                ctx.stroke();
                freePoints.push(p);
            }

        });

        canvas.addEventListener('pointerup', e => {
            canvas.releasePointerCapture(e.pointerId);
            if (mode === 'bg') {
                if (bgTouches.length > 0) { e.preventDefault(); }
                bgTouches = bgTouches.filter(t => t.pointerId !== e.pointerId);
                if (bgTouches.length < 2) bgStartGesture = null;
                if (bgTouches.length === 0) bgStartTransform = null;
                return;
            }
            if (mode === 'free' && freePoints.length > 1) {
                history.push({ type: 'free', color: currentColor, points: [...freePoints] });
            }
            drawing = false;
        });

        /* ==================== GEO POINTERS ==================== */
        function forwardPointerToCanvas(e) {
            const evt = new PointerEvent(e.type, {
                pointerId: e.pointerId,
                clientX: e.clientX,
                clientY: e.clientY,
                pointerType: e.pointerType,
                isPrimary: e.isPrimary,
                bubbles: true
            });
            canvas.dispatchEvent(evt);
        }

        geo.addEventListener('pointerdown', e => {

            const inside = isPointInsideGeo(e.clientX, e.clientY, geoPadding);
            const nearLine = isNearGeoBase(e.clientX, e.clientY, snap_abstand);

            // =========================================================
            // FALL 1: Finger ist NICHT im Geodreieck ‚Üí an Canvas weitergeben
            // =========================================================
            if (!inside) {

                // ganz wichtig: Bild darf den Pointer nicht behalten
                e.preventDefault();
                e.stopPropagation();

                const evt = new PointerEvent('pointerdown', {
                    pointerId: e.pointerId,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pointerType: e.pointerType,
                    isPrimary: e.isPrimary,
                    bubbles: true
                });

                canvas.dispatchEvent(evt);
                return;
            }

            // =========================================================
            // FALL 2: Finger an Grundlinie ‚Üí Zeichnen mit Geodreieck
            // =========================================================
            if (nearLine) {

                geoDrawingMode = true;

                const evt = new PointerEvent('pointerdown', {
                    pointerId: e.pointerId,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pointerType: e.pointerType,
                    isPrimary: e.isPrimary,
                    bubbles: true
                });

                canvas.dispatchEvent(evt);
                return;
            }

            // =========================================================
            // FALL 3: Finger wirklich IM Geodreieck ‚Üí bewegen
            // =========================================================
            geoDrawingMode = false;

            geo.setPointerCapture(e.pointerId);
            touches.push(e);

            if (!geoStartTransform)
                geoStartTransform = cloneGeo();
        });



        geo.addEventListener('pointermove', e => {

            // Wenn Finger nicht im Geodreieck gestartet hat ‚Üí ignorieren
            if (!geo.hasPointerCapture(e.pointerId) && !geoDrawingMode)
                return;

            // ===== ZEICHENMODUS -> Event ans Canvas weitergeben =====
            if (geoDrawingMode) {
                const evt = new PointerEvent('pointermove', {
                    pointerId: e.pointerId,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pointerType: e.pointerType,
                    isPrimary: e.isPrimary,
                    bubbles: true
                });
                canvas.dispatchEvent(evt);
                return;
            }

            // ===== BEWEGEN / ROTIEREN / SKALIEREN DES GEODREIECKS =====
            e.preventDefault();

            const prev = touches.find(t => t.pointerId === e.pointerId);
            touches = touches.map(t => t.pointerId === e.pointerId ? e : t);

            // --- Verschieben (1 Finger) ---
            if (touches.length === 1 && prev) {
                const dx = e.clientX - prev.clientX;
                const dy = e.clientY - prev.clientY;
                baseTransform.x += dx;
                baseTransform.y += dy;
                updateGeo();
            }

            // --- Zwei Finger: Rotation + Skalierung ---
            if (touches.length === 2) {

                const [a, b] = touches;
                const dx = b.clientX - a.clientX;
                const dy = b.clientY - a.clientY;

                const dist = Math.hypot(dx, dy);
                const ang = Math.atan2(dy, dx);

                const w = geo.width;
                const h = geo.height;
                const localPivot = { x: w / 2, y: h };

                function transformWithAngle(angle) {
                    let x = localPivot.x - w / 2;
                    let y = localPivot.y - h / 2;

                    x *= baseTransform.scale;
                    y *= baseTransform.scale;

                    const cosA = Math.cos(angle);
                    const sinA = Math.sin(angle);

                    return {
                        x: x * cosA - y * sinA + geo.offsetLeft + w / 2 + baseTransform.x,
                        y: x * sinA + y * cosA + geo.offsetTop + h / 2 + baseTransform.y
                    };
                }

                if (!startGesture) {
                    startGesture = {
                        dist,
                        ang,
                        scale: baseTransform.scale,
                        angle: baseTransform.angle
                    };
                }

                const P_before = transformWithAngle(baseTransform.angle);

                if (geoScaleMode === 'flexible') {
                    baseTransform.scale = startGesture.scale * (dist / startGesture.dist);
                }

                baseTransform.angle = startGesture.angle + (ang - startGesture.ang);

                const P_after = transformWithAngle(baseTransform.angle);

                baseTransform.x += (P_before.x - P_after.x);
                baseTransform.y += (P_before.y - P_after.y);

                updateGeo();
            }
        });

        geo.addEventListener('pointerup', e => {

            if (!geo.hasPointerCapture(e.pointerId) && !geoDrawingMode)
                return;

            // ===== Wenn Zeichnen -> ans Canvas weiterreichen =====
            if (geoDrawingMode) {

                const evt = new PointerEvent('pointerup', {
                    pointerId: e.pointerId,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pointerType: e.pointerType,
                    isPrimary: e.isPrimary,
                    bubbles: true
                });

                canvas.dispatchEvent(evt);

                geoDrawingMode = false;
                return;
            }

            // ===== sonst normales Geodreieck-Handling =====
            geo.releasePointerCapture(e.pointerId);

            touches = touches.filter(t => t.pointerId !== e.pointerId);

            if (touches.length === 0 && geoStartTransform) {
                history.push({
                    type: 'geo',
                    from: geoStartTransform,
                    to: cloneGeo()
                });
                geoStartTransform = null;
                startGesture = null;
            }

            // ggf. die groesse der Kaestchen anpassen -> dafuer redrawCanvas() aufrufen
            if (bgType === "grid") {
                redrawCanvas();
            }

        });

        /* ==================== GEO MOUSEWHEEL ==================== */
        geo.addEventListener('wheel', e => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.5 : -0.5;
            const angleDelta = delta * Math.PI / 180;
            const w = geo.width, h = geo.height;
            const localPivot = { x: w / 2, y: h };
            function transformPointWithAngle(px, py, angle) {
                let x = px - w / 2, y = py - h / 2;
                x *= baseTransform.scale; y *= baseTransform.scale;
                const cosA = Math.cos(angle), sinA = Math.sin(angle);
                const xr = x * cosA - y * sinA, yr = x * sinA + y * cosA;
                return { x: xr + geo.offsetLeft + w / 2 + baseTransform.x, y: yr + geo.offsetTop + h / 2 + baseTransform.y };
            }
            const P_before = transformPointWithAngle(localPivot.x, localPivot.y, baseTransform.angle);
            baseTransform.angle += angleDelta;
            const P_after = transformPointWithAngle(localPivot.x, localPivot.y, baseTransform.angle);
            baseTransform.x += (P_before.x - P_after.x); baseTransform.y += (P_before.y - P_after.y);
            updateGeo();
        });

    </script>


</body>

</html>
